# RWR written in itself
- RWR means ReWRite
- RWR is an SCN (nano-DSL) for generating the Javascript required by the OhmJS parsing tool
- background: using OhmJS, 
  - you write a grammar in a DSL that looks a lot like BNF
  - you supplement that grammar with a set of Javascript functions (arranged in a Javascript "namespace") to
	handle processing of the CST (concrete syntax tree) after a successful parse
  - OhmJS inhales text and parses it according to the grammar, and constructs a CST representing what it found
  - when there are no parsing errors, then OhmJS punts the rest of the work to the Javascript functions, which
	effectively do a tree-walk of the CST and take appropriate actions based on the contents of tree (this is
	called "semantics" by OhmJS).
- RWR restricts all semantic operations to be /only/ string creation and string interpolation
- each semantic function in RWR returns exactly one string
- a tree-walk uinsg RWR results in a single string, which is the composition of smaller strings generated during
  the tree-walk (a recursive building-up of the final string)
- this /sounds/ wildly restrictive, but, is incredibly useful, and, AFAICT, is the epitome of "Functional Programming"
- OhmJS + RWR can be used to build "t2t" transpilers (text-to-text transpilers) which inhale text and exhale rewritten text
  - this is what "macros" are in Lisp
  - this is what "compilers" are (compilers inhale high-level programming languages and exhale assembler text (some
	compilers then, also, convert the assembler text to binary, but that is just an optimization and is beyond 
	what RWR is generally meant for))
  - using OhmJS + RWR, you can, now, write "macros" for non-lisp languages (languages based on text) - easily
- aside: OhmJS is based on PEG
  - the designers of OhmJS trimmed-down the syntax to make it more readable
  - OhmJS supports left-recursion, whereas off-the-shelf PEG does not
  - OhmJS separates grammar specification from semantics specification, resulting in better readability
	- most PEG libraries tend to conflate grammar plus semantics in their syntax
  - OhmJS rules can perform automatic space-skipping, which trims noise out of grammars, resulting in better readability
  - OhmJS provides a syntax for parameterizing rules, resulting in better readability and better writeability
  - OhmJS eliminates some choices, thereby simplifying parser specification, namely, the programmer is not allowed to choose
	which matching predicates are named and saved - in OhmJS, all matching predicates are saved and sent to the 
	semantics functions, the programmer only gets to choose what name to use for each, and not whether the predicate is saved
- aside: OhmJS can parse matching brackets, recursively to any depth, something which standard CFG-based
  parsers cannot do
  - this means that OhmJS can be used in new ways, to build simpler, leaners parsers
  - this means that OhmJS is useful beyond the idea of building "compilers", and, OhmJS can be used in nano-projects
	instead of mega-projects
  - this means that OhmJS can parse interesting bits of text while "skipping over" uninteresting bits (something
	that CFG-based parsers cannot do)
  - this means that OhmJS can replace REGEXs for pattern-matching small snippets of text, like what REGEXs are used
	for, but,,,,, OhmJS parses recursively, where REGEXs are not recursive, hence, OhmJS can parse much more
	interesting bits of text than what REGEXs can be used for. 
		- example: imagine building a piece of code that inhales a Javascript program and exhales the name of
			every top-level function
				- you can do this in OhmJS
				- you can't do this using a REGEX, because a Javascript program can contain scope blocks `{...}`
				  nested to arbitrary levels, and, because the syntax of REGEX is so obtuse that any attempt at
				  parsing this kind of thing becomes an unreadable mess
			    - you can probably do this using recursive-descent Javascript functions plus non-recursive REGEXs, 
				  but,,,
				  why bother? why not use a DSL that is specially designed for this kind of thing? When you finish
				  writing the code in Javascript+REGEX, no one else can understand why you wrote the code the way
				  you did - they have to reverse-engineer the code in hopes of recovering your Design Intent, whereas
				  using a DSL (an OhmJS grammar) expresses your Design Intent more succinctly
- see example.js for a full-blown OhmJS program that parses something very simple
  - see example.ohm and example.rwr for specification of exactly the same simple program using a grammar plus an RWR spec
  - see example.out.js for the Javascript generated by the RWR spec
  - see example.generated.js for a full-blown Javascript program that parses the very same simple text, but uses 
	code that was generated by RWR
	
